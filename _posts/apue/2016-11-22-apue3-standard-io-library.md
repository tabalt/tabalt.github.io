---

layout: post
title:  "第5章：标准I/O库"
date:   2016-11-22 12:30:00
categories: 博文
tags: []

---

包括Unix在内的很多操作系统都实现了标准I/O库，标准I/O库处理缓冲区分配、以优化的块长度执行I/O等很多细节，以便于用户使用，但同时也需要深入的了解I/O库函数的操作，避免带来问题。

### 流和FILE对象

标准I/O库的操作是围绕流（stream）进行的，使用标准I/O库打开或创建一个文件即使一个流和一个文件相关联。

ASCII字符集使用一个字节表示一个字符，国际字符集使用多个字节表示一个字符。标准I/O文件流可用于单字节或多字节（宽）字符集。流的定向决定了读写的字符是单字节还是多字节。新创建的流没有定向，先使用单字节I/O函数操作未定向的流，则将流的定向设置为字节定向，相反则设置为宽定向。freopen函数可以清除一个流的定向，fwide函数可以设置未定向流的定向。

标准I/O函数fopen返回一个指向FILE对象的指针（称为文件指针），为了引用流需要将该指针作为参数传递给每个标准的I/O函数。FILE结构体包含了标准I/O库管理流的所有信息：

* 用于实际I/O的文件描述符
* 指向用于该流缓冲区的指针
* 缓冲区的长度
* 当前在缓冲区的字符数
* 出错标志等


### 标准输入、标准输出和标准错误

一个进程预定义了3个可以自动被进程使用的流：标准输入、标准输出和标准错误，分别用文件指针stdin、stdout、stderr加以引用。


### 缓冲

标准I/O库对每个I/O流自动进行缓冲管理，目的是尽可能减少使用read和write系统调用的次数。缓冲类型有如下三种：

* 全缓冲

    填满标准I/O缓冲区后才进行实际I/O操作，驻留磁盘上的文件通常是全缓冲。缓冲区可由标准I/O函数自动冲洗（将缓冲区的内容写到磁盘上），也可以调用fflush函数冲洗。

* 行缓冲

    输入和输出中遇到换行符后填满缓冲区时，标准I/O执行I/O操作。当流涉及到终端（标准输入和标准输出）时，通常使用行缓冲。
    
    通过标准I/O库从内核系统调用（不带缓冲的流或者暂无缓冲的行缓冲流）而得到输入数据，会冲洗所有行缓冲输出流。

* 不带缓冲

    标准I/O库不对字符进行缓冲存储。标准错误流stderr通常是不带缓冲的，以使错误尽快显示。


setbuf系列函数可以在流打开后执行其他操作钱调用而更改缓冲类型。缓冲的长度通常应由操作系统选择（BUFSIZ常量或stat结构的st_blksize字段），setvbuf函数时也可以手动指定。


### 打开流

fopen系列函数打开一个标准的I/O流：

* fopen函数打开指定文件路径的流
* freopen在一个指定的流上打开指定的文件，若流已打开则先关闭，若流已定向则清除定向，一般用于标准输入、标准输出和标准错误流
* fdopen从一个已有的文件描述符创建I/O流，常用于不能由fopen打开的创建管道和网络通信通道函数返回的描述符

打开流时的type参数hiding对流的读写方式，主要有15种值：

* r或rb，为读打开
* w或wb，把文件截断至0长，或为写创建
* a或ab，追加，为在文件尾写而打开或或为写创建
* r+或r+b或rb+，为读和写而打开
* w+或w+b或wb+，把文件截断至0长，或为读和写打开
* a+或a+b或ab+，为在文件为读写而打开或创建

追加写类型打开一个文件后，每次写都将写到文件的当前尾端处，即使多个进程追加写方式打开同一个文件也能正确写入。

以读和写类型打开文件有下列限制：

* 如果中间没有fflush、fseek、fsetpos、或rewind，则在输出的后面不能直接跟随输入
* 如果中间没有fseek、fsetpos、rewind或者输入操作没有到达文件尾端，则输入操作之后不能直接跟随输出

使用fclose可以关闭一个打开的流，文件被关闭前，会冲洗缓冲中的数据，缓冲中的任何输入数据被丢弃，标准io库自动分配的缓冲区被释放。


### 读和写流

打开流后可以使用以下3种不同类型的非格式化I/O进行读、写操作：

* 每次一个字符的I/O，一次读写一个字符，如果流带缓冲标准I/O函数处理所有缓冲
* 每次一行的I/O，使用fgets或fputs函数，每行以一个换行符终止
* 直接I/O，使用fread和fwrite函数，每次I/O操作读、写某种数量的具有指定长度的对象，常用于二进制文件中读或写一个结构

**输入函数**

getc、fgetc、getchar（等于getc(stdin)）可用于一次读一个字符，为了能在出错或达到文件末尾时返回EOF（-1），返回值会将unsigned char类型转换为int类型。如要区分是出错还是到达文件尾端，需要使用ferror或feof函数，它们分别读写FILE结构中的出错标志和文件结束标识；使用clearerr可以清除这两个标志。

从流中读取数据以后，可以调用ungetc将字符再压送回流中。压送回流的字符以后可以又从流中读出，但读出的顺序与压送回的顺序相反。每次只能回送一个字符，但允许任何次数的回送。回送的字符可以是EOF之外的任意字符，已到达文件末尾仍然可以回送字符并正常读取（成功ungetc回清楚文件结束标志）。回送的字符只是写回标准I/O的缓冲中而并没有写到底层文件或设备上。在切词或几号切分时会经常用到回送字符操作。


**输出函数**

putc、fputc、putchar（等于putc(c, stdout)）函数可用于一次写一个字符。


### 每次一行I/O

fgets、gets（不推荐使用）函数提供每次输入一行的功能，需要指定缓冲区地址。fgets函数需要指定缓冲区长度，缓冲区以null字符结尾，当行内容超过该长度时返回的是不完整的行，常常需要循环多次读取。

fputs、puts（避免使用）函数提供每次输出一行的功能。fputs将一个以null字符结尾的字符串写到指定的流，null字符不写出。如null字符前没有换行符则并不是输出一行。


### 标准I/O的效率

getc和putc函数可以实现为宏，因此相比fget从和fputc效率可能更高。fgets和fputs为了比getc和putc高效，一般会采用汇编编写的memccpy函数。标准I/O库与直接调用read和write函数相比并不慢很多。


### 二进制I/O

fread和fwrite函数可以执行二进制I/O操作，读写一个二进制数组或结构，返回读写的对象数。二进制I/O通常只能读在同一个系统上已写的数据，在一个系统上写的数据要在另一个系统上处理则不能正常工作，原因是：

* 一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同（不同的对齐要求）
* 用来存储多字节整数和浮点数的二进制格式在不同的系统结构中也可能不同


### 定位流

有三种方法可以定位标准I/O流：

* ftell和fseek函数
* ftello和fseeko函数
* fgetpos和fsetpos函数

需要移植到非Unix系统上的程序应当使用fgetpos和fsetpos函数。


### 格式化I/O

**格式化输出**

printf系列函数用来格式化输出，其中sprintf函数可能造成缓冲区溢出而推荐使用snprintf函数。 格式转换说明格式如下（[]中是可选部分）：

```
%[flags][fldwidth][precision][lenmodifier]convtype

flags：  标志部分
    ‘       将整数按千位分组
    -       字段内做对齐输出
    +       总是显示带符号转换的正负号
   ( )      如第一个字符不是正负号则加上一个空格
    #       指定另一种转换形式（如16进制加0x前缀）
    0       添加前导0而不是空格进行填充

fldwidth：  最小字段宽度，空格填充
precision： 整型转换后最少输出数字位数、浮点数转换后小数点后最少位数、字符串转换后最大字节数
lenmodifier：    参数长度
    hh      signed或unsigned char类型输出
    h       signed或unsigned short类型输出
    l       signed或unsigned long或宽类型输出
    ll      signed或unsigned long long类型输出
    j       intmax_t或uintmax_t
    z       size_t
    t       prtdiff_t
    L       long double
convtype:   转换类型
   d,i      有符号十进制
    o       无符号八进制
    u       无符号十进制
   x,X      无符号十六进制
   f,F      双精度浮点数
   e,E      指数格式双进度浮点数
   g,G      根据转换后的只解释为f、F、e或E
   a,A      十六进制指数格式双精度浮点数
    c       字符（有长度修饰符l则为宽字符）
    s       字符串（有长度修饰符l则为宽字符）
    p       指向void的指针
    n       到目前为止printf调用输出的字符数目
    %       一个%字符
    C       宽字符（lc）
    S       宽字符串（ls）
```

vprintf系列变体函数可以使用arg参数替换可变参数表(...)


**格式化输入**





更多有关[《Unix环境高级编程 3》的读书笔记](http://tabalt.net/blog/advanced-programming-in-the-unix-environment-3-reading-notes/)，请关注 ：   
[http://tabalt.net/blog/advanced-programming-in-the-unix-environment-3-reading-notes/](http://tabalt.net/blog/advanced-programming-in-the-unix-environment-3-reading-notes/)


